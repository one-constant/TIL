#### References

-   [5강 - 퀵 정렬(Quick Sort)의 시간 복잡도와 작동 원리 [ 실전 알고리즘 강좌(Algorithm Programming Tutorial) #5 ]](https://www.youtube.com/watch?v=O-O-90zX-U4&list=PLRx0vPvlEmdDHxCvAQS1_6XV4deOwfVrz&index=5)
-   [[알고리즘] 퀵 정렬(quick sort)이란](https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html)



### 서론

이번에는 퀵 정렬에 대해서 알아본다. 

퀵 정렬은 이름에서 알 수 있듯 기존의 알고리즘들에 비해서 시간 복잡도를 대폭 줄인 알고리즘이다. 지금까지 정렬 (1)~(4)에서 다룬 알고리즘들의 시간복잡도는 $O(\textrm{N^2})$ 이었던 데 반해, 퀵 정렬의 평균 시간 복잡도는 $O(\textrm{N*logN})$ 이다. (물론 최악의 경우를 상정하면 퀵 정렬의 시간 복잡도도 $O(\textrm{N^2})$ 이다. )

여기서 N이 log N 으로 바뀐 것은 엄청나게 큰 변화인데, N이 10 배 증가할 때 마다 log N은 1씩 증가하는데 이 경우 log는 거의 상수나 마찬가지이기 때문이다.  

본론에서는 퀵 정렬의 아이디어와 구체적인 진행 과정에 대해서 알아보도록 하자.



### 본론

퀵 정렬의 아이디어는 다음과 같다.

`Divide and conquer!`

이게 무슨 의미인지는 과정을 살펴보면 알 수 있다.



#### 과정

알고리즘에 따라 진행되는 과정은 다음과 같다.

1.  가장 앞에 있는 원소를 피벗값으로 설정한다.

2.  왼쪽에서부터 피벗 값보다 큰 값을 찾는다. 
    찾지 못하면 피벗 값이 가장 큰 값이다.

    한편, 오른쪽에서부터 피벗값보다 작은 값을 찾는다. 
    찾지 못하면 피벗 값이 가장 작은 값이다.

3.  그 후 숫자를 다음의 규칙에 따라 교환한다.

    1.  **피벗 값** / ··· / 큰 값 / ··· / 작은 값 / ··· 의 경우

        ⇒   `큰 값을 작은 값과 스위치한다.`

    2.  **피벗 값** / ··· / 작은 값 / ··· / 큰 값 / ··· 의 경우

        ⇒  `피벗 값과 작은 값을 스위치한다.`

4.  3 까지 수행했다면, 피벗 값은 제 자리에 정렬되었다. 이제 피벗 값을 기준으로 왼쪽은 피벗 값보다 작은 값, 오른쪽은 피벗 값보다 큰 값으로 나뉜다. 이제 왼쪽과 오른쪽에 대해서 따로따로 (순환적으로) 1~3의 과정을 반복해준다. 



표를 통해 어떻게 진행되는 것인지 확인해보자.

피벗 값은 <u>0</u> 언더라인으로, 

피벗 값보다 큰 값은 **0** 굵은 글씨로

피벗 값보다 작은 값은 *0* 이텔릭체로 

정렬이 완료된 값을 ~~0~~ 취소선으로 표시하겠다.

|           | index | 0             | 1        | 2     | 3        | 4     | 5    | 6    | 7    | 8     | 9      |
| --------- | ----- | ------------- | -------- | ----- | -------- | ----- | ---- | ---- | ---- | ----- | ------ |
| 초기 배열 |       | 10            | 3        | 5     | 2        | 7     | 8    | 4    | 6    | 9     | 1      |
| 1회차     |       | <u>**10**</u> | 3        | 5     | 2        | 7     | 8    | 4    | 6    | 9     | *1*    |
|           |       | 1             | 3        | 5     | 2        | 7     | 8    | 4    | 6    | 9     | ~~10~~ |
| 2회차     |       | *<u>1</u>*    | 3        | 5     | 2        | 7     | 8    | 4    | 6    | **9** | ~~10~~ |
|           |       | ~~1~~         | 3        | 5     | 2        | 7     | 8    | 4    | 6    | 9     | ~~10~~ |
| 3회차     |       | ~~1~~         | <u>3</u> | **5** | *2*      | 7     | 8    | 4    | 6    | 9     | ~~10~~ |
|           |       | ~~1~~         | <u>3</u> | *2*   | **5**    | 7     | 8    | 4    | 6    | 9     | ~~10~~ |
|           |       | ~~1~~         | 2        | ~~3~~ | 5        | 7     | 8    | 4    | 6    | 9     | ~~10~~ |
| 4회차     |       | ~~1~~         | <u>2</u> | ~~3~~ | <u>5</u> | 7     | 8    | 4    | 6    | 9     | ~~10~~ |
|           |       | ~~1~~         | ~~2~~    | ~~3~~ | <u>5</u> | **7** | 8    | *4*  | 6    | 9     | ~~10~~ |
| ...       |       |               |          |       |          |       |      |      |      |       |        |



#### 시간복잡도

왜 퀵 정렬은  $O(\textrm{N*logN})$ 의 시간복잡도를 가지는지 생각해보자.







알고리즘을 구현한 코드는 아래와 같다.

#### C

```C
void quickSort(int arr[], int start, int end){
    int pivot, big, small, temp;

    if(start >= end){ // 정렬할 요소가 없는 경우 나간다.
        return;
    }

    pivot = arr[start];  // 맨 앞의 값을 pivot 값으로 설정한다.
    big = start;  // 오른쪽으로 진행하며 pivot 값보다 큰 값을 찾는다.
    small = end;  // 왼쪽으로 진행하며 pivot 값보다 작은 값을 찾는다.

    while(pivot == arr[small]){  // pivot 값의 위치가 '작은 값'과 바뀐 경우 이번 회차의 정렬이 완료된 것이다. 
        while(pivot >= arr[big]){  // 오른쪽으로 진행할 때, pivot 값보다 작은 값은 그냥 넘긴다.
            big++;
            if(big > end){  // 주어진 구간[start, end]에서 pivot 값보다 큰 값이 없는 경우, big > end 가 된다.
                big = start;  // 이런 경우 pivot값이 가장 큰 값이 된다.
                break;
            }
        }
        while (pivot <= arr[small]) {  // 왼쪽으로 진행할 때, pivot 값보다 큰 값은 그냥 넘긴다.
            small--;
            if(small < start){  // 주어진 구간[start, end]에서 pivot 값보다 작은 값이 없는 경우, small < end 가 된다.
                small = start;  // 이런 경우 pivot 값이 가장 작은 값이 된다.
                break;
            }
        }

        if (big < small) {  // 배열에서 큰 값이 작은 값보다 앞에 있는 경우, 큰 값과 작은 값의 위치를 바꿔준다.
            temp = arr[big];
            arr[big] = arr[small];
            arr[small] = temp;
            
        } else {  // 배열에서 작은 값이 큰 값보다 뒤에 있는 경우, pivot 값과 작은 값의 위치를 바꿔준다.
            arr[start] = arr[small];
            arr[small] = pivot;
        }
    }
    quickSort(arr, start, small-1);  // 정렬된 pivot 값을 기준으로 앞쪽을 정렬한다.
    quickSort(arr, small+1, end); // 정렬된 pivot 값을 기준으로 뒷쪽을 정렬한다.
}
```



### 결론

