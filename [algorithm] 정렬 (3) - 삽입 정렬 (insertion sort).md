#### Reference

-   [4강 - 삽입 정렬(Insertion Sort) [ 실전 알고리즘 강좌(Algorithm Programming Tutorial) #4 ]](https://www.youtube.com/watch?v=16I9Z7bS1iM&t=219s)
-   [삽입 정렬](https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC)



#### 본론

삽입 정렬의 아이디어는 

`제 자리에 꽂는다`

라는 것이다. 어떻게 동작하는지 확인해보자.



아래와 같은 배열이 있다고 하자.

| 10   | 3    | 5    | 2    | 7    | 8    | 4    | 6    | 9    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

맨 앞에 놓인 숫자 10은 제 자리에 놓여있다고 가정한다. 

맨 처음 회차에서는 3을 본다. 3은 10을 기준으로 왼쪽 혹은 오른쪽에 놓일 수 있지만, 10보다 작으므로 왼쪽에 놓인다.

| 3    | 10   | 5    | 2    | 7    | 8    | 4    | 6    | 9    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

그 다음 회차에서는 5를 본다. 5보다 앞 부분은 잘 정렬되어 있다(라고 삽입 정렬 알고리즘은 생각한다). 5 바로 앞에 있는 10은 5보다 크므로 순서를 바꾸어 준다. 그 후 5 앞에 있는 3은 5보다 작으므로 순서를 바꾸지 않는다.

| 3    | 5    | 10   | 2    | 7    | 8    | 4    | 6    | 9    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |



이런 방식으로 진행된다면 n개의 수가 있을 때 **최대**

$\sum\limits_{k=1}^{n} k= 1 + 2 + 3 + ... + n-1 = \frac{n(n-1)}{2}$ 만큼 연산이 수행될 것임을 알 수 있다. 

따라서 선택 정렬 알고리즘의 복잡도는 $O(N^2)$ 이다.

이는 앞서 본 선택 정렬이나 버블 정렬과 동일한 복잡도이다. 실제로 최악의 경우를 가정한다면 버블 정렬과 동일한 연산을 처리해야 할 것이다.

하지만 삽입 정렬은 선택 정렬이나 버블 정렬에 비해서 더 높은 성능을 보여주는데 그 이유는 정렬해야 하는 수가 자기 자리를 찾아가면 더 이상의 불필요한 연산을 하지 않고 다음 회차로 넘어가기 때문이다. 그러므로 거의 정렬된 상태라면 선택/버블 정렬에 비해 훨씬 빠르게 정렬을 수행할 수 있다.



삽입 정렬을 구현한 코드는 아래와 같다.

#### C

```c
#include <stdio.h>

void insertionSort(int arr[], int size){
    int i, j, temp;
    for (i = 1; i < size; i++) {
        j = i - 1;
        while (arr[j] > arr[j + 1]) {
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
            j--;
        }
    }

    for(i=0; i<size; i++){
        printf("%d ", arr[i]);
    }
}
```


