#### References

-   [셸 정렬](https://ko.wikipedia.org/wiki/%EC%85%B8_%EC%A0%95%EB%A0%AC)
-   [[알고리즘] 셸 정렬(shell sort)이란](https://gmlwjd9405.github.io/2018/05/08/algorithm-shell-sort.html)



#### 본론

셸 정렬은 삽입 정렬의 단점을 보완하고자 하는 시도에서 개발된 방법이다.

삽입 정렬의 경우 **이미 대부분 정렬이 잘 되어 있는 배열의 경우에는 잘 작동**하지만,

**삽입 되어야 하는 위치가 현재 위치로부터 먼 경우 많은 수의 이동이 필요하다는 단점**이 있다.



이를 보완한 셸 정렬의 아이디어는 다음과 같다.

`쪼갠 후 삽입 정렬한다.`

라는 것이다. 



알고리즘에 따라 진행되는 과정은 다음과 같다.

1.  N개의 데이터를 가지고 있을 때, $\frac{N}{3} = k_1$ 개의 Subfile을 만든다. $k_1$ 를 gap이라고 한다. 이 때, $k_1$ 가 짝수라면 홀수로 바꿔준다. 
2.  각 Subfile 별로 삽입 정렬한다.
3.  $\frac{k_1}{3}=k_2$ 개의 subfile을 만든다. 마찬가지로 짝수면 홀수로 바꿔준다. 그 후, 각 Subfile 별로 삽입 정렬한다.
4.  위의 과정을 반복한다.



표를 통해 어떻게 진행되는 것인지 확인해보자.

| index              | 0      | 1    | 2        | 3     | 4    | 5        | 6     | 7    | 8        | 9      |
| ------------------ | ------ | ---- | -------- | ----- | ---- | -------- | ----- | ---- | -------- | ------ |
| 초기 배열          | 10     | 3    | 5        | 2     | 7    | 8        | 4     | 6    | 9        | 1      |
| $k=\frac{10}{3}=3$ |        |      |          |       |      |          |       |      |          |        |
| Subfile1           | **10** |      |          | **2** |      |          | **4** |      |          | **1**  |
| Subfile2           |        | *3*  |          |       | *7*  |          |       | *6*  |          |        |
| Subfile3           |        |      | <u>5</u> |       |      | <u>8</u> |       |      | <u>9</u> |        |
| 1 사이클 후        | **1**  | *3*  | <u>5</u> | **2** | *6*  | <u>8</u> | **4** | *7*  | <u>9</u> | **10** |



알고리즘을 구현한 코드는 아래와 같다.

#### C

```C
void shellSort(int arr[], int size){
    int i, j, k, temp, gap;

    for(gap = size/3; gap > 0; gap = gap/3){  // gap 을 설정한다.
        if(gap % 2 == 0){
            gap++; // gap 이 짝수인 경우, 1을 더해준다. 
            	   //이때 0인 경우는 반복문에 진입하지 못하기 때문에 걱정하지 않아도 된다.
        }

        for (i = 0; i < gap; i++) {  
            // Subshell 각각에 대한 삽입 정렬이 이루어진다.
            for (j = 0; gap * (j+1) + i < size; j++) {
                // 각각의 Subshell의 원소는 gap만큼의 index 차이가 있다.
                // gap * (j+1) + i > size 라는 것은 
                // gap * j + i 가 subshell의 마지막 원소라는 것이다.
                
                k=j;
                while(arr[gap * k + i] > arr[gap * (k+1) + i]){
                    temp = arr[gap * k + i];
                    arr[gap * k + i] = arr[gap * (k+1) + i];
                    arr[gap * (k+1) + i] = temp;
                    if (k>0) k--;
                }
            }
        }
    }

    for(i=0; i<size; i++){
        printf("%d ", arr[i]);
    }
}
```

