선택 정렬 알고리즘은 가장 기초적인 정렬 알고리즘이다.

선택 정렬의 아이디어는 

`가장 작은 것을 가장 앞으로 보내라`

라는 것이다. 어떻게 동작하는지 확인해보자.



아래와 같은 배열이 있다고 하자.

| 10   | 3    | 5    | 2    | 7    | 8    | 4    | 6    | 9    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

선택 정렬 알고리즘에서는 위 배열의 모든 수를 확인 한 다음, 가장 작은 수인 1을 배열의 맨 앞에 있는 10과 자리를 바꾼다.

| 1    | 3    | 5    | 2    | 7    | 8    | 4    | 6    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

그 후, 1을 제외한 나머지 부분의 배열을 모두 확인한 다음 가장 작은 수인 2와 3의 자리를 바꾼다.

| 1    | 2    | 5    | 3    | 7    | 8    | 4    | 6    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |



이런 방식으로 진행된다면 n개의 수가 있을 때 

$n + (n-1) + (n-2) + ... + 1 = \frac{n(n+1)}{2}$ 만큼 연산이 수행될 것임을 알 수 있다. 

따라서 선택 정렬 알고리즘의 복잡도는 $O(N^2)$ 이다. ~~구데기같은 성능~~



선택 정렬을 구현한 코드는 아래와 같다.

#### C

```c
#include <stdio.h>

void selectionSort(int arr[], int size){
    int i, j, temp, minIndex;
    for (i = 0; i < size; i++) {
        minIndex = size-1;
        for (j = i; j < size; j++) {
            if(arr[minIndex] > arr[j]) {
                minIndex = j;
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }

    for(i=0; i<size; i++){
        printf("%d ", arr[i]);
    }
}

int main() {
    int arr[10] = {10,3,5,2,7,8,4,6,9,1};
    selectionSort(arr, 10);
    return 0;
}
```



여기서 4행에서의 코드를 작성하지 않으면 결과가 

`1 2 3 4 5 6 10 7 8 9`  가 나와서 상당히 당황스러웠다. 그 이유를 찾아보기 위해 직접 표를 그려보았다.

| index | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1회   | 10   | 3    | 5    | 2    | 7    | 8    | 4    | 6    | 9    | 1    |
| 2회   | 1    | 3    | 5    | 2    | 7    | 8    | 4    | 6    | 9    | 10   |
| 3회   | 1    | 2    | 5    | 3    | 7    | 8    | 4    | 6    | 9    | 10   |
| 4회   | 1    | 2    | 3    | 5    | 7    | 8    | 4    | 6    | 9    | 10   |
| 5회   | 1    | 2    | 3    | 4    | 5    | 8    | 7    | 6    | 9    | 10   |
| 6회   | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| 7회   | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| 8회   | 1    | 2    | 3    | 4    | 5    | 6    | 8    | 7    | 9    | 10   |
| 9회   | 1    | 2    | 3    | 4    | 5    | 6    | 9    | 7    | 8    | 10   |
| 10회  | 1    | 2    | 3    | 4    | 5    | 6    | 10   | 7    | 8    | 9    |

6회의 정렬에서 이미 정렬은 완료되었는데 그 이후로 `minIndex` 값이 업데이트 되지 않아서 계속 index 6으로 index i 이상의 수들이 swap 되어서 발생한 문제였다.

